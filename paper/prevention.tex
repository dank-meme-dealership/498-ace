\section{How Arbitrary Code Execution Can Be Prevented}

Because of the potentially catastrophic situations that can arise from arbitrary code execution exploits, several methods for preventing it have been implemented. Most end-all solutions take place in the C compiler (such as \texttt{gcc}); solutions for other languages like Bash tend to more specific to individual exploits that have occurred.

One low-level solution for preventing arbitrary code execution is the inclusion of a no-execute (NX or XD depending on the processor) bit on the CPU. In essence, this method marks certain parts of memory executable (such as the \texttt{.text} segment in a program), while leaving other parts of memory marked as non-executable (such as the \texttt{.data} segment in the program). Then, before executing any instructions, the CPU checks this no-execute bit to see if the memory it is executing from should be executed or not. If the instruction pointer ever moves to a place in memory that is not marked as executable, the program faults and exits. The inclusion and usage of a no-execute bit has been present in Windows since Windows XP SP2 (7). This method is very good in preventing code being executed from portions of memory that are controlled by the user (such as strings built from user input), but it does not stop every exploit. For instance, the Dirty COW exploit on Linux that arose recently took advantage of rewriting the \texttt{.text} segment, so even a no-execute bit couldn’t have prevented arbitrary code from being executed.

Another solution that is in-use today by \texttt{gcc} is the inclusion of a stack canary during execution. The idea behind this is that most (not all) arbitrary code execution exploits take advantage of manipulating the call stack to return execution to a new place in memory and ultimately execute code that was not intended to be executed. In an attempt to prevent this, a small random integer is placed just before the call stack in memory. Since the most common way to overwrite the stack is to overflow memory writing from normal memory into the stack, any code trying to write its way into the call stack will have to overwrite the stack canary (8). This canary value is checked often, and if it is ever not equal to the original random value it was assigned, then the stack might have been manipulated and the program faults. Of course, like the no-execute bit, this solution is not full proof. In fact, the same exploit that bypasses an no-execute bit (Dirty COW) could bypass a stack canary just as easily.

Basic prevention of arbitrary code execution can stop many exploits from ever occurring, but a program is almost never truly safe. Even if a program is written and compiled with extreme care, bugs can still be exploited in the compiler or operating system. Developers should always be aware of the third-party libraries they are using in their programs and pay attention to any potential exploits that can arise from them. They should also make sure to always use the safe copying functions in C (such as \texttt{strncpy} instead of \texttt{strcpy}). Finally, they should be proactive in fixing any bugs that show signs of allowing arbitrary code execution to exist. Even if fixes are implemented and updates are launched the day an exploit is discovered, machines that aren’t up to date can still be compromised and huge problems can still occur.
